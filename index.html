<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aggro PvP â€” Smoke Overlay (Canvas)</title>
<style>
  html,body{height:100%;margin:0;padding:0;background:#000;font-family:system-ui,monospace;color:#fff}
  /* core UI */
  .center{position:relative;z-index:10;text-align:center;padding:40px}
  .logo{width:70%;max-width:320px;display:block;margin:0 auto 18px}
  .btn{display:inline-block;padding:10px 18px;border-radius:8px;background:#111;color:#ff4444;text-decoration:none;border:2px solid rgba(255,68,68,0.12);margin:8px}
  /* top canvas overlay (pointer-events:none keeps UI clickable) */
  #smokeCanvas{
    position:fixed;
    inset:0;
    z-index:9999;
    pointer-events:none;
    display:block;
  }
  /* small debugging toggle */
  .debug-toggle{position:fixed;left:16px;bottom:16px;z-index:10001;background:#111;color:#fff;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06)}
</style>
</head>
<body>

  <!-- UI -->
  <main class="center" id="mainUI">
    <img src="Aggro-logo.PNG" alt="Aggro PvP Logo" class="logo" />
    <div>
      <a class="btn" href="#">ðŸŽ® Connect to Server</a>
      <a class="btn" href="#">ðŸ’¬ Join Discord</a>
    </div>
  </main>

  <!-- Canvas overlay: topmost visual layer, still doesn't block clicks -->
  <canvas id="smokeCanvas" aria-hidden="true"></canvas>

  <!-- Optional small button for toggling overlay while testing (still clickable because it's above canvas) -->
  <button id="toggleOverlay" class="debug-toggle">Toggle Smoke (S)</button>

<script>
/*
  Canvas smoke overlay
  - Draws multiple layers of a transparent Smoke.png
  - Each layer scrolls up at its own speed and scale to create parallax
  - Keeps UI clickable via pointer-events:none on the canvas element
  - Controls: press "S" or click Toggle to hide/show
*/

(() => {
  const canvas = document.getElementById('smokeCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  const img = new Image();
  img.src = 'Smoke.png'; // must be a transparent PNG in same folder (case-sensitive)
  img.crossOrigin = 'anonymous';

  // Layers configuration: adjust speed, scale, opacity per layer
  const layers = [
    { offset: 0, speed: 0.18, scale: 1.05, alpha: 0.95 },
    { offset: 0, speed: 0.10, scale: 1.3,  alpha: 0.82 },
    { offset: 0, speed: 0.06, scale: 1.6,  alpha: 0.72 }
  ];

  let width = 0, height = 0, last = 0, playing = true;
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing for DPR
  }

  // Convert a "virtual" layer coordinate into the repeated pattern drawing
  function drawLayer(layer, t) {
    if (!img.width) return;
    const layerW = img.width * layer.scale;
    const layerH = img.height * layer.scale;

    // vertical offset loops: use offset that increases over time
    const speed = layer.speed * height; // pixels per second relative to viewport
    layer.offset = (layer.offset - speed * (t / 1000)) % layerH;

    ctx.globalAlpha = layer.alpha;
    ctx.globalCompositeOperation = 'screen'; // nice glow; change to 'source-over' or 'normal' if you prefer
    // center horizontally, tile vertically so smoke never gaps
    const centerX = width / 2;
    const drawX = centerX - layerW / 2;

    // draw enough tiles to cover viewport vertically (start one tile above top to ensure continuous flow)
    for (let y = -layerH + layer.offset; y < height + layerH; y += layerH) {
      ctx.drawImage(img, drawX, y, layerW, layerH);
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }

  function clear() {
    ctx.clearRect(0, 0, width, height);
  }

  function animate(now) {
    if (!last) last = now;
    const dt = now - last;
    last = now;

    clear();
    if (playing && img.complete && img.naturalWidth) {
      // draw layers back-to-front (furthest drawn first)
      for (let i = layers.length - 1; i >= 0; i--) {
        drawLayer(layers[i], dt);
      }
    }
    requestAnimationFrame(animate);
  }

  // Setup
  window.addEventListener('resize', resize);
  resize();

  // Start after image loads; allow fallback if image fails
  img.onload = () => {
    // Seed offsets so layers start at different vertical positions
    layers.forEach((L, i) => L.offset = (i * (img.height * L.scale) / 2) % (img.height * L.scale));
  };
  img.onerror = () => console.warn('Smoke image failed to load. Ensure Smoke.png exists and path is correct.');

  requestAnimationFrame(animate);

  // Toggle via S key and button
  const toggleBtn = document.getElementById('toggleOverlay');
  function toggle() {
    playing = !playing;
    canvas.style.display = playing ? 'block' : 'none';
    // keep toggle button visible for testing
    toggleBtn.textContent = playing ? 'Toggle Smoke (S)' : 'Smoke Hidden (S)';
  }
  toggleBtn.addEventListener('click', toggle);
  window.addEventListener('keydown', (e) => { if (e.key === 's' || e.key === 'S') toggle(); });

  // Expose a small API if needed
  window.__AggroSmoke = {
    setOpacity(layerIndex, value) { if (layers[layerIndex]) layers[layerIndex].alpha = value; },
    setSpeed(layerIndex, value) { if (layers[layerIndex]) layers[layerIndex].speed = value; },
    show() { playing = true; canvas.style.display = 'block'; },
    hide() { playing = false; canvas.style.display = 'none'; }
  };
})();
</script>
</body>
</html>
